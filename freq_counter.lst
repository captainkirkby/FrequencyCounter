   1               		.file	"freq_counter.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               		.section	.text.startup,"ax",@progbits
  14               	.global	main
  16               	main:
  17               	.LFB7:
  18               		.file 1 "freq_counter.c"
   1:freq_counter.c **** #include <stdlib.h>
   2:freq_counter.c **** #include <avr/io.h>
   3:freq_counter.c **** #include <avr/pgmspace.h>
   4:freq_counter.c **** #include <util/delay.h>
   5:freq_counter.c **** #include "lcd.h"
   6:freq_counter.c **** #include <avr/interrupt.h>
   7:freq_counter.c **** 
   8:freq_counter.c **** 
   9:freq_counter.c **** #define STR_LEN                 33
  10:freq_counter.c **** #define HIGH                    1
  11:freq_counter.c **** #define LOW                     0
  12:freq_counter.c **** 
  13:freq_counter.c **** #define COUNTER_MIN_VALUE       1000
  14:freq_counter.c **** #define CALIBRATION_CONSTANT    1000000
  15:freq_counter.c **** 
  16:freq_counter.c **** #define AVG_AMT                 100
  17:freq_counter.c **** #define LCD_WRITE_RATE          10
  18:freq_counter.c **** 
  19:freq_counter.c **** int main(void)
  20:freq_counter.c **** {   
  19               		.loc 1 20 0
  20               		.cfi_startproc
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  21:freq_counter.c ****     DDRB &=~ (1 << PB2);
  25               		.loc 1 21 0
  26 0000 2298      		cbi 36-32,2
  22:freq_counter.c ****     PORTB |= (1 << PB2);
  27               		.loc 1 22 0
  28 0002 2A9A      		sbi 37-32,2
  23:freq_counter.c **** 
  24:freq_counter.c ****     DDRB |= (1 << PB3);
  29               		.loc 1 24 0
  30 0004 239A      		sbi 36-32,3
  25:freq_counter.c **** 
  26:freq_counter.c ****     /* initialize display, cursor off */
  27:freq_counter.c ****     lcd_init(LCD_DISP_ON);
  31               		.loc 1 27 0
  32 0006 8CE0      		ldi r24,lo8(12)
  33 0008 0E94 0000 		call lcd_init
  34               	.LVL0:
  28:freq_counter.c **** 
  29:freq_counter.c ****     // 32 bit count can be incremented once per clock cycle and
  30:freq_counter.c ****     // not overflow for 2^32 / 16MHz = 268.435456 seconds
  31:freq_counter.c ****     // Seems like a safe value
  32:freq_counter.c ****     uint32_t counter;
  33:freq_counter.c ****     uint32_t intermediateCounterValue;
  34:freq_counter.c **** 
  35:freq_counter.c ****     // Circular buffer to keep track of buffer length
  36:freq_counter.c ****     uint32_t soFar[AVG_AMT];
  37:freq_counter.c ****     uint16_t soFarNdx = 0;
  38:freq_counter.c ****     uint32_t avg;
  39:freq_counter.c ****     uint16_t avgNdx = 0;
  40:freq_counter.c **** 
  41:freq_counter.c ****     // Should we write to the LCD
  42:freq_counter.c ****     int lcdWrite = 0;
  43:freq_counter.c **** 
  44:freq_counter.c ****     // String to hold printing data
  45:freq_counter.c ****     char intCountStr[STR_LEN];
  46:freq_counter.c ****     char fraccountStr[STR_LEN];
  47:freq_counter.c **** 
  48:freq_counter.c ****     // Frequency variables
  49:freq_counter.c ****     uint32_t freqInt;
  50:freq_counter.c ****     uint32_t freqFrac;
  51:freq_counter.c **** 
  52:freq_counter.c ****     uint8_t lastState = PINB & _BV(PINB2);
  35               		.loc 1 52 0
  36 000c 83B1      		in r24,35-32
  53:freq_counter.c ****     cli();
  37               		.loc 1 53 0
  38               	/* #APP */
  39               	 ;  53 "freq_counter.c" 1
  40 000e F894      		cli
  41               	 ;  0 "" 2
  42               	.LVL1:
  43               	/* #NOAPP */
  44               	.L8:
  54:freq_counter.c **** 
  55:freq_counter.c ****     for (;;) {
  56:freq_counter.c ****         // Prepare for capturing the falling edge
  57:freq_counter.c ****         counter = 0;
  58:freq_counter.c **** 
  59:freq_counter.c ****         PORTB |= (1 << PB3);
  45               		.loc 1 59 0
  46 0010 2B9A      		sbi 37-32,3
  57:freq_counter.c ****         counter = 0;
  47               		.loc 1 57 0
  48 0012 80E0      		ldi r24,lo8(0)
  49 0014 90E0      		ldi r25,hi8(0)
  50 0016 DC01      		movw r26,r24
  60:freq_counter.c **** 
  61:freq_counter.c ****         // Count while the positive pulse is happening with a minimum to avoid bounce
  62:freq_counter.c ****         while ((PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  51               		.loc 1 62 0
  52 0018 00C0      		rjmp .L2
  53               	.LVL2:
  54               	.L3:
  63:freq_counter.c ****             counter++;
  55               		.loc 1 63 0
  56 001a 0196      		adiw r24,1
  57 001c A11D      		adc r26,__zero_reg__
  58 001e B11D      		adc r27,__zero_reg__
  59               	.LVL3:
  60               	.L2:
  62:freq_counter.c ****         while ((PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  61               		.loc 1 62 0 discriminator 1
  62 0020 1A99      		sbic 35-32,2
  63 0022 00C0      		rjmp .L3
  62:freq_counter.c ****         while ((PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  64               		.loc 1 62 0 is_stmt 0 discriminator 2
  65 0024 883E      		cpi r24,lo8(1000)
  66 0026 23E0      		ldi r18,hi8(1000)
  67 0028 9207      		cpc r25,r18
  68 002a 20E0      		ldi r18,hlo8(1000)
  69 002c A207      		cpc r26,r18
  70 002e 20E0      		ldi r18,hhi8(1000)
  71 0030 B207      		cpc r27,r18
  72 0032 00F0      		brlo .L3
  62:freq_counter.c ****         while ((PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  73               		.loc 1 62 0
  74 0034 80E0      		ldi r24,lo8(0)
  75 0036 90E0      		ldi r25,hi8(0)
  76 0038 DC01      		movw r26,r24
  77               	.LVL4:
  78 003a 00C0      		rjmp .L4
  79               	.LVL5:
  80               	.L5:
  64:freq_counter.c ****         }
  65:freq_counter.c **** 
  66:freq_counter.c ****         intermediateCounterValue = counter;
  67:freq_counter.c ****         counter = 0;
  68:freq_counter.c **** 
  69:freq_counter.c ****         // Count while the negative pulse is happening with a minimum to avoid bounce
  70:freq_counter.c ****         while (!(PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  71:freq_counter.c ****             counter++;
  81               		.loc 1 71 0 is_stmt 1
  82 003c 0196      		adiw r24,1
  83 003e A11D      		adc r26,__zero_reg__
  84 0040 B11D      		adc r27,__zero_reg__
  85               	.LVL6:
  86               	.L4:
  70:freq_counter.c ****         while (!(PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  87               		.loc 1 70 0 discriminator 1
  88 0042 1A9B      		sbis 35-32,2
  89 0044 00C0      		rjmp .L5
  70:freq_counter.c ****         while (!(PINB & (1 << PINB2)) || (counter < COUNTER_MIN_VALUE)) {
  90               		.loc 1 70 0 is_stmt 0 discriminator 2
  91 0046 883E      		cpi r24,lo8(1000)
  92 0048 23E0      		ldi r18,hi8(1000)
  93 004a 9207      		cpc r25,r18
  94 004c 20E0      		ldi r18,hlo8(1000)
  95 004e A207      		cpc r26,r18
  96 0050 20E0      		ldi r18,hhi8(1000)
  97 0052 B207      		cpc r27,r18
  98 0054 00F0      		brlo .L5
  72:freq_counter.c ****         }
  73:freq_counter.c **** 
  74:freq_counter.c ****         PORTB &= ~(1 << PB3);
  99               		.loc 1 74 0 is_stmt 1
 100 0056 2B98      		cbi 37-32,3
 101               	.LVL7:
 102               	.L6:
  75:freq_counter.c ****         
  76:freq_counter.c **** 
  77:freq_counter.c ****         counter += intermediateCounterValue;
  78:freq_counter.c **** 
  79:freq_counter.c ****         // A change happened!
  80:freq_counter.c ****         soFar[++soFarNdx % AVG_AMT] = counter;
  81:freq_counter.c **** 
  82:freq_counter.c ****         // get average of soFar
  83:freq_counter.c ****         for (avgNdx = 0; avgNdx < AVG_AMT; avgNdx++) {
  84:freq_counter.c ****             avg += soFar[avgNdx];
  85:freq_counter.c ****         }
  86:freq_counter.c ****         avg /= AVG_AMT;
  87:freq_counter.c ****     
  88:freq_counter.c ****         freqInt = CALIBRATION_CONSTANT / avg;
  89:freq_counter.c ****         freqFrac = ((CALIBRATION_CONSTANT % counter) * (100)) / avg;
  90:freq_counter.c **** 
  91:freq_counter.c ****         // //Write to LCD
  92:freq_counter.c ****         // lcd_clrscr();
  93:freq_counter.c ****         // sprintf(intCountStr, "%d.", freqInt);
  94:freq_counter.c ****         // lcd_puts(intCountStr);
  95:freq_counter.c ****         // sprintf(fraccountStr, "%02d Hz\n", freqFrac);
  96:freq_counter.c ****         // lcd_puts(fraccountStr);
  97:freq_counter.c **** 
  98:freq_counter.c ****         // Wait again for the bounce to stop
  99:freq_counter.c ****         counter = 0;
 100:freq_counter.c ****         while (counter < COUNTER_MIN_VALUE) {
 101:freq_counter.c ****             counter++;
 102:freq_counter.c ****         }
 103:freq_counter.c **** 
 104:freq_counter.c ****         // Wait until the positive pulse is done
 105:freq_counter.c ****         while ((PINB & (1 << PINB2)))
 103               		.loc 1 105 0 discriminator 1
 104 0058 1A99      		sbic 35-32,2
 105 005a 00C0      		rjmp .L6
 106               	.L9:
 106:freq_counter.c ****             ;
 107:freq_counter.c **** 
 108:freq_counter.c ****         // Wait again for the bounce to stop
 109:freq_counter.c ****         counter = 0;
 110:freq_counter.c ****         while (counter < COUNTER_MIN_VALUE) {
 111:freq_counter.c ****             counter++;
 112:freq_counter.c ****         }
 113:freq_counter.c **** 
 114:freq_counter.c **** 
 115:freq_counter.c ****         // Wait until the negative pulse is done
 116:freq_counter.c ****         while (!(PINB & (1 << PINB2)))
 107               		.loc 1 116 0 discriminator 1
 108 005c 1A9B      		sbis 35-32,2
 109 005e 00C0      		rjmp .L9
 110 0060 00C0      		rjmp .L8
 111               		.cfi_endproc
 112               	.LFE7:
 114               		.text
 115               	.Letext0:
 116               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 freq_counter.c
      freq_counter.s:2      *ABS*:0000003f __SREG__
      freq_counter.s:3      *ABS*:0000003e __SP_H__
      freq_counter.s:4      *ABS*:0000003d __SP_L__
      freq_counter.s:5      *ABS*:00000034 __CCP__
      freq_counter.s:6      *ABS*:00000000 __tmp_reg__
      freq_counter.s:7      *ABS*:00000001 __zero_reg__
      freq_counter.s:16     .text.startup:00000000 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
lcd_init
