   1               		.file	"uart.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	__vector_18
  15               	__vector_18:
  16               	.LFB1:
  17               		.file 1 "uart.c"
   1:uart.c        **** /*************************************************************************
   2:uart.c        **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:uart.c        **** Author:   Peter Fleury <pfleury@gmx.ch>   http://tinyurl.com/peterfleury
   4:uart.c        **** File:     $Id: uart.c,v 1.15.2.4 2015/09/05 18:33:32 peter Exp $
   5:uart.c        **** Software: AVR-GCC 4.x
   6:uart.c        **** Hardware: any AVR with built-in UART, 
   7:uart.c        **** License:  GNU General Public License 
   8:uart.c        ****           
   9:uart.c        **** DESCRIPTION:
  10:uart.c        ****     An interrupt is generated when the UART has finished transmitting or
  11:uart.c        ****     receiving a byte. The interrupt handling routines use circular buffers
  12:uart.c        ****     for buffering received and transmitted data.
  13:uart.c        ****     
  14:uart.c        ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:uart.c        ****     the buffer size in bytes. Note that these variables must be a 
  16:uart.c        ****     power of 2.
  17:uart.c        ****     
  18:uart.c        **** USAGE:
  19:uart.c        ****     Refere to the header file uart.h for a description of the routines. 
  20:uart.c        ****     See also example test_uart.c.
  21:uart.c        **** 
  22:uart.c        **** NOTES:
  23:uart.c        ****     Based on Atmel Application Note AVR306
  24:uart.c        ****                     
  25:uart.c        **** LICENSE:
  26:uart.c        ****     Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3
  27:uart.c        **** 
  28:uart.c        ****     This program is free software; you can redistribute it and/or modify
  29:uart.c        ****     it under the terms of the GNU General Public License as published by
  30:uart.c        ****     the Free Software Foundation; either version 2 of the License, or
  31:uart.c        ****     any later version.
  32:uart.c        **** 
  33:uart.c        ****     This program is distributed in the hope that it will be useful,
  34:uart.c        ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:uart.c        ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:uart.c        ****     GNU General Public License for more details.
  37:uart.c        ****                         
  38:uart.c        **** *************************************************************************/
  39:uart.c        **** #include <avr/io.h>
  40:uart.c        **** #include <avr/interrupt.h>
  41:uart.c        **** #include <avr/pgmspace.h>
  42:uart.c        **** #include "uart.h"
  43:uart.c        **** 
  44:uart.c        **** 
  45:uart.c        **** /*
  46:uart.c        ****  *  constants and macros
  47:uart.c        ****  */
  48:uart.c        **** 
  49:uart.c        **** /* size of RX/TX buffers */
  50:uart.c        **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  51:uart.c        **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  52:uart.c        **** 
  53:uart.c        **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  54:uart.c        **** #error RX buffer size is not a power of 2
  55:uart.c        **** #endif
  56:uart.c        **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  57:uart.c        **** #error TX buffer size is not a power of 2
  58:uart.c        **** #endif
  59:uart.c        **** 
  60:uart.c        **** 
  61:uart.c        **** #if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \
  62:uart.c        ****     defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || \
  63:uart.c        ****     defined(__AVR_ATmega103__)
  64:uart.c        ****  /* old AVR classic or ATmega103 with one UART */
  65:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  66:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  67:uart.c        ****  #define UART0_STATUS      USR
  68:uart.c        ****  #define UART0_CONTROL     UCR
  69:uart.c        ****  #define UART0_DATA        UDR  
  70:uart.c        ****  #define UART0_UDRIE       UDRIE
  71:uart.c        ****  #define UART0_UBRRL       UBRR
  72:uart.c        ****  #define UART0_BIT_U2X     U2X
  73:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
  74:uart.c        ****  #define UART0_BIT_RXEN    RXEN
  75:uart.c        ****  #define UART0_BIT_TXEN    TXEN
  76:uart.c        **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  77:uart.c        ****  /* old AVR classic with one UART */
  78:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  79:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  80:uart.c        ****  #define UART0_STATUS      UCSRA
  81:uart.c        ****  #define UART0_CONTROL     UCSRB
  82:uart.c        ****  #define UART0_DATA        UDR 
  83:uart.c        ****  #define UART0_UDRIE       UDRIE
  84:uart.c        ****  #define UART0_UBRRL       UBRR
  85:uart.c        ****  #define UART0_BIT_U2X     U2X
  86:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
  87:uart.c        ****  #define UART0_BIT_RXEN    RXEN
  88:uart.c        ****  #define UART0_BIT_TXEN    TXEN
  89:uart.c        **** #elif defined(__AVR_AT90PWM216__) || defined(__AVR_AT90PWM316__) 
  90:uart.c        ****  /* AT90PWN216/316 with one USART */
  91:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
  92:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
  93:uart.c        ****  #define UART0_STATUS      UCSRA
  94:uart.c        ****  #define UART0_CONTROL     UCSRB
  95:uart.c        ****  #define UART0_CONTROLC    UCSRC
  96:uart.c        ****  #define UART0_DATA        UDR
  97:uart.c        ****  #define UART0_UDRIE       UDRIE
  98:uart.c        ****  #define UART0_UBRRL       UBRRL
  99:uart.c        ****  #define UART0_UBRRH       UBRRH
 100:uart.c        ****  #define UART0_BIT_U2X     U2X
 101:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 102:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 103:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 104:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ0
 105:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ1 
 106:uart.c        **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) || \
 107:uart.c        ****       defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) || \
 108:uart.c        ****       defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) || \
 109:uart.c        ****       defined(__AVR_ATmega323__)
 110:uart.c        ****  /* ATmega with one USART */
 111:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 112:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 113:uart.c        ****  #define UART0_STATUS      UCSRA
 114:uart.c        ****  #define UART0_CONTROL     UCSRB
 115:uart.c        ****  #define UART0_CONTROLC    UCSRC
 116:uart.c        ****  #define UART0_DATA        UDR
 117:uart.c        ****  #define UART0_UDRIE       UDRIE
 118:uart.c        ****  #define UART0_UBRRL       UBRRL
 119:uart.c        ****  #define UART0_UBRRH       UBRRH
 120:uart.c        ****  #define UART0_BIT_U2X     U2X
 121:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 122:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 123:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 124:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ0
 125:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ1
 126:uart.c        ****  #define UART0_BIT_URSEL   URSEL
 127:uart.c        **** #elif defined (__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 128:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 129:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 130:uart.c        ****  #define UART0_STATUS      UCSRA
 131:uart.c        ****  #define UART0_CONTROL     UCSRB
 132:uart.c        ****  #define UART0_CONTROLC    UCSRC 
 133:uart.c        ****  #define UART0_DATA        UDR
 134:uart.c        ****  #define UART0_UDRIE       UDRIE
 135:uart.c        ****  #define UART0_UBRRL       UBRRL
 136:uart.c        ****  #define UART0_UBRRH       UBRRH
 137:uart.c        ****  #define UART0_BIT_U2X     U2X
 138:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 139:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 140:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 141:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ0
 142:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ1
 143:uart.c        ****  #define UART0_BIT_URSEL   URSEL
 144:uart.c        **** #elif defined(__AVR_ATmega163__)
 145:uart.c        ****   /* ATmega163 with one UART */
 146:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 147:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 148:uart.c        ****  #define UART0_STATUS      UCSRA
 149:uart.c        ****  #define UART0_CONTROL     UCSRB
 150:uart.c        ****  #define UART0_DATA        UDR
 151:uart.c        ****  #define UART0_UDRIE       UDRIE
 152:uart.c        ****  #define UART0_UBRRL       UBRR
 153:uart.c        ****  #define UART0_UBRRH       UBRRHI
 154:uart.c        ****  #define UART0_BIT_U2X     U2X
 155:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 156:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 157:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 158:uart.c        **** #elif defined(__AVR_ATmega162__) 
 159:uart.c        ****  /* ATmega with two USART */
 160:uart.c        ****  #define ATMEGA_USART1
 161:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 162:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 163:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 164:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 165:uart.c        ****  #define UART0_STATUS      UCSR0A
 166:uart.c        ****  #define UART0_CONTROL     UCSR0B
 167:uart.c        ****  #define UART0_CONTROLC    UCSR0C
 168:uart.c        ****  #define UART0_DATA        UDR0
 169:uart.c        ****  #define UART0_UDRIE       UDRIE0
 170:uart.c        ****  #define UART0_UBRRL       UBRR0L
 171:uart.c        ****  #define UART0_UBRRH       UBRR0H
 172:uart.c        ****  #define UART0_BIT_URSEL   URSEL0
 173:uart.c        ****  #define UART0_BIT_U2X     U2X0
 174:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE0
 175:uart.c        ****  #define UART0_BIT_RXEN    RXEN0
 176:uart.c        ****  #define UART0_BIT_TXEN    TXEN0
 177:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ00
 178:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ01
 179:uart.c        ****  #define UART1_STATUS      UCSR1A
 180:uart.c        ****  #define UART1_CONTROL     UCSR1B
 181:uart.c        ****  #define UART1_CONTROLC    UCSR1C
 182:uart.c        ****  #define UART1_DATA        UDR1
 183:uart.c        ****  #define UART1_UDRIE       UDRIE1
 184:uart.c        ****  #define UART1_UBRRL       UBRR1L
 185:uart.c        ****  #define UART1_UBRRH       UBRR1H
 186:uart.c        ****  #define UART1_BIT_URSEL   URSEL1
 187:uart.c        ****  #define UART1_BIT_U2X     U2X1
 188:uart.c        ****  #define UART1_BIT_RXCIE   RXCIE1
 189:uart.c        ****  #define UART1_BIT_RXEN    RXEN1
 190:uart.c        ****  #define UART1_BIT_TXEN    TXEN1
 191:uart.c        ****  #define UART1_BIT_UCSZ0   UCSZ10
 192:uart.c        ****  #define UART1_BIT_UCSZ1   UCSZ11 
 193:uart.c        **** #elif defined(__AVR_ATmega161__)
 194:uart.c        ****  /* ATmega with UART */
 195:uart.c        ****  #error "AVR ATmega161 currently not supported by this libaray !"
 196:uart.c        **** #elif defined(__AVR_ATmega169__)
 197:uart.c        ****  /* ATmega with one USART */
 198:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 199:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 200:uart.c        ****  #define UART0_STATUS      UCSRA
 201:uart.c        ****  #define UART0_CONTROL     UCSRB
 202:uart.c        ****  #define UART0_CONTROLC    UCSRC
 203:uart.c        ****  #define UART0_DATA        UDR
 204:uart.c        ****  #define UART0_UDRIE       UDRIE
 205:uart.c        ****  #define UART0_UBRRL       UBRRL
 206:uart.c        ****  #define UART0_UBRRH       UBRRH
 207:uart.c        ****  #define UART0_BIT_U2X     U2X
 208:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 209:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 210:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 211:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ0
 212:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ1
 213:uart.c        **** #elif defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48P__) || defi
 214:uart.c        ****       defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) || defi
 215:uart.c        ****       defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__)|| defined(__AVR_ATmega168P__)|| def
 216:uart.c        ****       defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || \
 217:uart.c        ****       defined(__AVR_ATmega3250__) || defined(__AVR_ATmega3290__) ||defined(__AVR_ATmega6450__) || d
 218:uart.c        ****  /* ATmega with one USART */
 219:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 220:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 221:uart.c        ****  #define UART0_STATUS      UCSR0A
 222:uart.c        ****  #define UART0_CONTROL     UCSR0B
 223:uart.c        ****  #define UART0_CONTROLC    UCSR0C
 224:uart.c        ****  #define UART0_DATA        UDR0
 225:uart.c        ****  #define UART0_UDRIE       UDRIE0
 226:uart.c        ****  #define UART0_UBRRL       UBRR0L
 227:uart.c        ****  #define UART0_UBRRH       UBRR0H
 228:uart.c        ****  #define UART0_BIT_U2X     U2X0
 229:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE0
 230:uart.c        ****  #define UART0_BIT_RXEN    RXEN0
 231:uart.c        ****  #define UART0_BIT_TXEN    TXEN0
 232:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ00
 233:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ01
 234:uart.c        **** #elif defined(__AVR_ATtiny2313__) || defined(__AVR_ATtiny2313A__) || defined(__AVR_ATtiny4313__)
 235:uart.c        ****  /* ATtiny with one USART */
 236:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 237:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 238:uart.c        ****  #define UART0_STATUS      UCSRA
 239:uart.c        ****  #define UART0_CONTROL     UCSRB
 240:uart.c        ****  #define UART0_CONTROLC    UCSRC
 241:uart.c        ****  #define UART0_DATA        UDR
 242:uart.c        ****  #define UART0_UDRIE       UDRIE
 243:uart.c        ****  #define UART0_UBRRL       UBRRL
 244:uart.c        ****  #define UART0_UBRRH       UBRRH
 245:uart.c        ****  #define UART0_BIT_U2X     U2X
 246:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE
 247:uart.c        ****  #define UART0_BIT_RXEN    RXEN
 248:uart.c        ****  #define UART0_BIT_TXEN    TXEN
 249:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ0
 250:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ1
 251:uart.c        **** #elif defined(__AVR_ATmega329__) || defined(__AVR_ATmega649__) || defined(__AVR_ATmega3290__) || de
 252:uart.c        ****       defined(__AVR_ATmega169A__) || defined(__AVR_ATmega169PA__) || \
 253:uart.c        ****       defined(__AVR_ATmega329A__) || defined(__AVR_ATmega329PA__) || defined(__AVR_ATmega3290A__) |
 254:uart.c        ****       defined(__AVR_ATmega649A__) || defined(__AVR_ATmega649P__) || defined(__AVR_ATmega6490A__) ||
 255:uart.c        ****       defined(__AVR_ATmega165__) || defined(__AVR_ATmega325__) || defined(__AVR_ATmega645__) || def
 256:uart.c        ****       defined(__AVR_ATmega165A__) || defined(__AVR_ATmega165PA__) || \
 257:uart.c        ****       defined(__AVR_ATmega325A__) || defined(__AVR_ATmega325PA__) || defined(__AVR_ATmega3250A__) |
 258:uart.c        ****       defined(__AVR_ATmega645A__) || defined(__AVR_ATmega645PA__) || defined(__AVR_ATmega6450A__) |
 259:uart.c        ****       defined(__AVR_ATmega644__)
 260:uart.c        ****  /* ATmega with one USART */
 261:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 262:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 263:uart.c        ****  #define UART0_STATUS      UCSR0A
 264:uart.c        ****  #define UART0_CONTROL     UCSR0B
 265:uart.c        ****  #define UART0_CONTROLC    UCSR0C
 266:uart.c        ****  #define UART0_DATA        UDR0
 267:uart.c        ****  #define UART0_UDRIE       UDRIE0
 268:uart.c        ****  #define UART0_UBRRL       UBRR0L
 269:uart.c        ****  #define UART0_UBRRH       UBRR0H
 270:uart.c        ****  #define UART0_BIT_U2X     U2X0
 271:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE0
 272:uart.c        ****  #define UART0_BIT_RXEN    RXEN0
 273:uart.c        ****  #define UART0_BIT_TXEN    TXEN0
 274:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ00
 275:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ01
 276:uart.c        **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) ||\
 277:uart.c        ****       defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || d
 278:uart.c        ****       defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || 
 279:uart.c        ****       defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega324A__) ||
 280:uart.c        ****       defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284__) ||
 281:uart.c        ****       defined(__AVR_ATtiny1634__)
 282:uart.c        ****  /* ATmega with two USART */
 283:uart.c        ****  #define ATMEGA_USART1
 284:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 285:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 286:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 287:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 288:uart.c        ****  #define UART0_STATUS      UCSR0A
 289:uart.c        ****  #define UART0_CONTROL     UCSR0B
 290:uart.c        ****  #define UART0_CONTROLC    UCSR0C  
 291:uart.c        ****  #define UART0_DATA        UDR0
 292:uart.c        ****  #define UART0_UDRIE       UDRIE0
 293:uart.c        ****  #define UART0_UBRRL       UBRR0L
 294:uart.c        ****  #define UART0_UBRRH       UBRR0H
 295:uart.c        ****  #define UART0_BIT_U2X     U2X0
 296:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE0
 297:uart.c        ****  #define UART0_BIT_RXEN    RXEN0
 298:uart.c        ****  #define UART0_BIT_TXEN    TXEN0
 299:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ00
 300:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ01 
 301:uart.c        ****  #define UART1_STATUS      UCSR1A
 302:uart.c        ****  #define UART1_CONTROL     UCSR1B
 303:uart.c        ****  #define UART1_CONTROLC    UCSR1C  
 304:uart.c        ****  #define UART1_DATA        UDR1
 305:uart.c        ****  #define UART1_UDRIE       UDRIE1
 306:uart.c        ****  #define UART1_UBRRL       UBRR1L
 307:uart.c        ****  #define UART1_UBRRH       UBRR1H
 308:uart.c        ****  #define UART1_BIT_U2X     U2X1
 309:uart.c        ****  #define UART1_BIT_RXCIE   RXCIE1
 310:uart.c        ****  #define UART1_BIT_RXEN    RXEN1
 311:uart.c        ****  #define UART1_BIT_TXEN    TXEN1
 312:uart.c        ****  #define UART1_BIT_UCSZ0   UCSZ10
 313:uart.c        ****  #define UART1_BIT_UCSZ1   UCSZ11
 314:uart.c        **** #elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || \
 315:uart.c        ****       defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || \
 316:uart.c        ****       defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
 317:uart.c        ****       defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB647__) ||
 318:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART1_RX_vect
 319:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 320:uart.c        ****  #define UART0_STATUS      UCSR1A
 321:uart.c        ****  #define UART0_CONTROL     UCSR1B
 322:uart.c        ****  #define UART0_CONTROLC    UCSR1C
 323:uart.c        ****  #define UART0_DATA        UDR1
 324:uart.c        ****  #define UART0_UDRIE       UDRIE1
 325:uart.c        ****  #define UART0_UBRRL       UBRR1L
 326:uart.c        ****  #define UART0_UBRRH       UBRR1H
 327:uart.c        ****  #define UART0_BIT_U2X     U2X1
 328:uart.c        ****  #define UART0_BIT_RXCIE   RXCIE1
 329:uart.c        ****  #define UART0_BIT_RXEN    RXEN1
 330:uart.c        ****  #define UART0_BIT_TXEN    TXEN1
 331:uart.c        ****  #define UART0_BIT_UCSZ0   UCSZ10
 332:uart.c        ****  #define UART0_BIT_UCSZ1   UCSZ11
 333:uart.c        **** #else
 334:uart.c        ****  #error "no UART definition for MCU available"
 335:uart.c        **** #endif
 336:uart.c        **** 
 337:uart.c        **** 
 338:uart.c        **** 
 339:uart.c        **** /*
 340:uart.c        ****  *  module global variables
 341:uart.c        ****  */
 342:uart.c        **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 343:uart.c        **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 344:uart.c        **** static volatile unsigned char UART_TxHead;
 345:uart.c        **** static volatile unsigned char UART_TxTail;
 346:uart.c        **** static volatile unsigned char UART_RxHead;
 347:uart.c        **** static volatile unsigned char UART_RxTail;
 348:uart.c        **** static volatile unsigned char UART_LastRxError;
 349:uart.c        **** 
 350:uart.c        **** #if defined( ATMEGA_USART1 )
 351:uart.c        **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 352:uart.c        **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 353:uart.c        **** static volatile unsigned char UART1_TxHead;
 354:uart.c        **** static volatile unsigned char UART1_TxTail;
 355:uart.c        **** static volatile unsigned char UART1_RxHead;
 356:uart.c        **** static volatile unsigned char UART1_RxTail;
 357:uart.c        **** static volatile unsigned char UART1_LastRxError;
 358:uart.c        **** #endif
 359:uart.c        **** 
 360:uart.c        **** 
 361:uart.c        **** 
 362:uart.c        **** ISR (UART0_RECEIVE_INTERRUPT)	
 363:uart.c        **** /*************************************************************************
 364:uart.c        **** Function: UART Receive Complete interrupt
 365:uart.c        **** Purpose:  called when the UART has received a character
 366:uart.c        **** **************************************************************************/
 367:uart.c        **** {
  18               		.loc 1 367 0
  19               		.cfi_startproc
  20 0000 1F92      		push r1
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 1, -2
  24 0002 0F92      		push r0
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 0, -3
  28 0004 0FB6      		in r0,__SREG__
  29 0006 0F92      		push r0
  30 0008 1124      		clr __zero_reg__
  31 000a 2F93      		push r18
  32               	.LCFI2:
  33               		.cfi_def_cfa_offset 5
  34               		.cfi_offset 18, -4
  35 000c 8F93      		push r24
  36               	.LCFI3:
  37               		.cfi_def_cfa_offset 6
  38               		.cfi_offset 24, -5
  39 000e 9F93      		push r25
  40               	.LCFI4:
  41               		.cfi_def_cfa_offset 7
  42               		.cfi_offset 25, -6
  43 0010 EF93      		push r30
  44               	.LCFI5:
  45               		.cfi_def_cfa_offset 8
  46               		.cfi_offset 30, -7
  47 0012 FF93      		push r31
  48               	.LCFI6:
  49               		.cfi_def_cfa_offset 9
  50               		.cfi_offset 31, -8
  51               	/* prologue: Signal */
  52               	/* frame size = 0 */
  53               	/* stack size = 8 */
  54               	.L__stack_usage = 8
 368:uart.c        ****     unsigned char tmphead;
 369:uart.c        ****     unsigned char data;
 370:uart.c        ****     unsigned char usr;
 371:uart.c        ****     unsigned char lastRxError;
 372:uart.c        ****  
 373:uart.c        ****  
 374:uart.c        ****     /* read UART status register and UART data register */
 375:uart.c        ****     usr  = UART0_STATUS;
  55               		.loc 1 375 0
  56 0014 9091 C000 		lds r25,192
  57               	.LVL0:
 376:uart.c        ****     data = UART0_DATA;
  58               		.loc 1 376 0
  59 0018 8091 C600 		lds r24,198
  60               	.LVL1:
 377:uart.c        ****     
 378:uart.c        ****     /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
 379:uart.c        **** #if defined(FE) && defined(DOR) && defined(UPE)
 380:uart.c        ****     lastRxError = usr & (_BV(FE)|_BV(DOR)|_BV(UPE) );
 381:uart.c        **** #elif defined(FE0) && defined(DOR0) && defined(UPE0)
 382:uart.c        ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
 383:uart.c        **** #elif defined(FE1) && defined(DOR1) && defined(UPE1)
 384:uart.c        ****     lastRxError = usr & (_BV(FE1)|_BV(DOR1)|_BV(UPE1) );
 385:uart.c        **** #elif defined(FE) && defined(DOR)
 386:uart.c        ****     lastRxError = usr & (_BV(FE)|_BV(DOR) );
 387:uart.c        **** #endif
 388:uart.c        **** 
 389:uart.c        ****     /* calculate buffer index */ 
 390:uart.c        ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  61               		.loc 1 390 0
  62 001c E091 0000 		lds r30,UART_RxHead
  63 0020 EF5F      		subi r30,lo8(-(1))
  64 0022 EF71      		andi r30,lo8(31)
  65               	.LVL2:
 391:uart.c        ****     
 392:uart.c        ****     if ( tmphead == UART_RxTail ) {
  66               		.loc 1 392 0
  67 0024 2091 0000 		lds r18,UART_RxTail
  68 0028 E217      		cp r30,r18
  69 002a 01F0      		breq .L3
 382:uart.c        ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
  70               		.loc 1 382 0
  71 002c 9C71      		andi r25,lo8(28)
  72               	.LVL3:
 393:uart.c        ****         /* error: receive buffer overflow */
 394:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 395:uart.c        ****     }else{
 396:uart.c        ****         /* store new index */
 397:uart.c        ****         UART_RxHead = tmphead;
  73               		.loc 1 397 0
  74 002e E093 0000 		sts UART_RxHead,r30
 398:uart.c        ****         /* store received data in buffer */
 399:uart.c        ****         UART_RxBuf[tmphead] = data;
  75               		.loc 1 399 0
  76 0032 F0E0      		ldi r31,lo8(0)
  77 0034 E050      		subi r30,lo8(-(UART_RxBuf))
  78 0036 F040      		sbci r31,hi8(-(UART_RxBuf))
  79               	.LVL4:
  80 0038 8083      		st Z,r24
  81 003a 00C0      		rjmp .L2
  82               	.LVL5:
  83               	.L3:
 394:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
  84               		.loc 1 394 0
  85 003c 92E0      		ldi r25,lo8(2)
  86               	.LVL6:
  87               	.L2:
 400:uart.c        ****     }
 401:uart.c        ****     UART_LastRxError |= lastRxError;   
  88               		.loc 1 401 0
  89 003e 8091 0000 		lds r24,UART_LastRxError
  90               	.LVL7:
  91 0042 892B      		or r24,r25
  92 0044 8093 0000 		sts UART_LastRxError,r24
  93               	/* epilogue start */
 402:uart.c        **** }
  94               		.loc 1 402 0
  95 0048 FF91      		pop r31
  96 004a EF91      		pop r30
  97 004c 9F91      		pop r25
  98               	.LVL8:
  99 004e 8F91      		pop r24
 100 0050 2F91      		pop r18
 101 0052 0F90      		pop r0
 102 0054 0FBE      		out __SREG__,r0
 103 0056 0F90      		pop r0
 104 0058 1F90      		pop r1
 105 005a 1895      		reti
 106               		.cfi_endproc
 107               	.LFE1:
 109               	.global	__vector_19
 111               	__vector_19:
 112               	.LFB2:
 403:uart.c        **** 
 404:uart.c        **** 
 405:uart.c        **** ISR (UART0_TRANSMIT_INTERRUPT)
 406:uart.c        **** /*************************************************************************
 407:uart.c        **** Function: UART Data Register Empty interrupt
 408:uart.c        **** Purpose:  called when the UART is ready to transmit the next byte
 409:uart.c        **** **************************************************************************/
 410:uart.c        **** {
 113               		.loc 1 410 0
 114               		.cfi_startproc
 115 005c 1F92      		push r1
 116               	.LCFI7:
 117               		.cfi_def_cfa_offset 3
 118               		.cfi_offset 1, -2
 119 005e 0F92      		push r0
 120               	.LCFI8:
 121               		.cfi_def_cfa_offset 4
 122               		.cfi_offset 0, -3
 123 0060 0FB6      		in r0,__SREG__
 124 0062 0F92      		push r0
 125 0064 1124      		clr __zero_reg__
 126 0066 8F93      		push r24
 127               	.LCFI9:
 128               		.cfi_def_cfa_offset 5
 129               		.cfi_offset 24, -4
 130 0068 9F93      		push r25
 131               	.LCFI10:
 132               		.cfi_def_cfa_offset 6
 133               		.cfi_offset 25, -5
 134 006a EF93      		push r30
 135               	.LCFI11:
 136               		.cfi_def_cfa_offset 7
 137               		.cfi_offset 30, -6
 138 006c FF93      		push r31
 139               	.LCFI12:
 140               		.cfi_def_cfa_offset 8
 141               		.cfi_offset 31, -7
 142               	/* prologue: Signal */
 143               	/* frame size = 0 */
 144               	/* stack size = 7 */
 145               	.L__stack_usage = 7
 411:uart.c        ****     unsigned char tmptail;
 412:uart.c        **** 
 413:uart.c        ****     
 414:uart.c        ****     if ( UART_TxHead != UART_TxTail) {
 146               		.loc 1 414 0
 147 006e 9091 0000 		lds r25,UART_TxHead
 148 0072 8091 0000 		lds r24,UART_TxTail
 149 0076 9817      		cp r25,r24
 150 0078 01F0      		breq .L5
 415:uart.c        ****         /* calculate and store new buffer index */
 416:uart.c        ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 151               		.loc 1 416 0
 152 007a E091 0000 		lds r30,UART_TxTail
 153 007e EF5F      		subi r30,lo8(-(1))
 154 0080 EF71      		andi r30,lo8(31)
 155               	.LVL9:
 417:uart.c        ****         UART_TxTail = tmptail;
 156               		.loc 1 417 0
 157 0082 E093 0000 		sts UART_TxTail,r30
 418:uart.c        ****         /* get one byte from buffer and write it to UART */
 419:uart.c        ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 158               		.loc 1 419 0
 159 0086 F0E0      		ldi r31,lo8(0)
 160 0088 E050      		subi r30,lo8(-(UART_TxBuf))
 161 008a F040      		sbci r31,hi8(-(UART_TxBuf))
 162               	.LVL10:
 163 008c 8081      		ld r24,Z
 164 008e 8093 C600 		sts 198,r24
 165 0092 00C0      		rjmp .L4
 166               	.LVL11:
 167               	.L5:
 420:uart.c        ****     }else{
 421:uart.c        ****         /* tx buffer empty, disable UDRE interrupt */
 422:uart.c        ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 168               		.loc 1 422 0
 169 0094 8091 C100 		lds r24,193
 170 0098 8F7D      		andi r24,lo8(-33)
 171 009a 8093 C100 		sts 193,r24
 172               	.L4:
 173               	/* epilogue start */
 423:uart.c        ****     }
 424:uart.c        **** }
 174               		.loc 1 424 0
 175 009e FF91      		pop r31
 176 00a0 EF91      		pop r30
 177 00a2 9F91      		pop r25
 178 00a4 8F91      		pop r24
 179 00a6 0F90      		pop r0
 180 00a8 0FBE      		out __SREG__,r0
 181 00aa 0F90      		pop r0
 182 00ac 1F90      		pop r1
 183 00ae 1895      		reti
 184               		.cfi_endproc
 185               	.LFE2:
 187               	.global	uart_init
 189               	uart_init:
 190               	.LFB3:
 425:uart.c        **** 
 426:uart.c        **** 
 427:uart.c        **** /*************************************************************************
 428:uart.c        **** Function: uart_init()
 429:uart.c        **** Purpose:  initialize UART and set baudrate
 430:uart.c        **** Input:    baudrate using macro UART_BAUD_SELECT()
 431:uart.c        **** Returns:  none
 432:uart.c        **** **************************************************************************/
 433:uart.c        **** void uart_init(unsigned int baudrate)
 434:uart.c        **** {
 191               		.loc 1 434 0
 192               		.cfi_startproc
 193               	.LVL12:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 435:uart.c        ****     UART_TxHead = 0;
 198               		.loc 1 435 0
 199 00b0 1092 0000 		sts UART_TxHead,__zero_reg__
 436:uart.c        ****     UART_TxTail = 0;
 200               		.loc 1 436 0
 201 00b4 1092 0000 		sts UART_TxTail,__zero_reg__
 437:uart.c        ****     UART_RxHead = 0;
 202               		.loc 1 437 0
 203 00b8 1092 0000 		sts UART_RxHead,__zero_reg__
 438:uart.c        ****     UART_RxTail = 0;
 204               		.loc 1 438 0
 205 00bc 1092 0000 		sts UART_RxTail,__zero_reg__
 439:uart.c        **** 
 440:uart.c        **** #ifdef UART_TEST
 441:uart.c        **** #ifndef UART0_BIT_U2X
 442:uart.c        **** #warning "UART0_BIT_U2X not defined"
 443:uart.c        **** #endif
 444:uart.c        **** #ifndef UART0_UBRRH
 445:uart.c        **** #warning "UART0_UBRRH not defined"
 446:uart.c        **** #endif
 447:uart.c        **** #ifndef UART0_CONTROLC
 448:uart.c        **** #warning "UART0_CONTROLC not defined"
 449:uart.c        **** #endif
 450:uart.c        **** #if defined(URSEL) || defined(URSEL0)
 451:uart.c        **** #ifndef UART0_BIT_URSEL
 452:uart.c        **** #warning "UART0_BIT_URSEL not defined"
 453:uart.c        **** #endif
 454:uart.c        **** #endif
 455:uart.c        **** #endif
 456:uart.c        **** 
 457:uart.c        ****     /* Set baud rate */
 458:uart.c        ****     if ( baudrate & 0x8000 )
 206               		.loc 1 458 0
 207 00c0 97FF      		sbrs r25,7
 208 00c2 00C0      		rjmp .L8
 459:uart.c        ****     {
 460:uart.c        ****         #if UART0_BIT_U2X
 461:uart.c        ****         UART0_STATUS = (1<<UART0_BIT_U2X);  //Enable 2x speed 
 209               		.loc 1 461 0
 210 00c4 22E0      		ldi r18,lo8(2)
 211 00c6 2093 C000 		sts 192,r18
 212               	.L8:
 462:uart.c        ****         #endif
 463:uart.c        ****     } 
 464:uart.c        ****     #if defined(UART0_UBRRH)
 465:uart.c        ****     UART0_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 213               		.loc 1 465 0
 214 00ca 9078      		andi r25,lo8(-128)
 215 00cc 9093 C500 		sts 197,r25
 466:uart.c        ****     #endif    
 467:uart.c        ****     UART0_UBRRL = (unsigned char) (baudrate&0x00FF);
 216               		.loc 1 467 0
 217 00d0 8093 C400 		sts 196,r24
 468:uart.c        ****       
 469:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 470:uart.c        ****     UART0_CONTROL = _BV(UART0_BIT_RXCIE)|(1<<UART0_BIT_RXEN)|(1<<UART0_BIT_TXEN);
 218               		.loc 1 470 0
 219 00d4 88E9      		ldi r24,lo8(-104)
 220               	.LVL13:
 221 00d6 8093 C100 		sts 193,r24
 471:uart.c        ****     
 472:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 473:uart.c        ****     #ifdef UART0_CONTROLC
 474:uart.c        ****     #ifdef UART0_BIT_URSEL
 475:uart.c        ****     UART0_CONTROLC = (1<<UART0_BIT_URSEL)|(1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 476:uart.c        ****     #else
 477:uart.c        ****     UART0_CONTROLC = (1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 222               		.loc 1 477 0
 223 00da 86E0      		ldi r24,lo8(6)
 224 00dc 8093 C200 		sts 194,r24
 225               	/* epilogue start */
 478:uart.c        ****     #endif 
 479:uart.c        ****     #endif
 480:uart.c        **** 
 481:uart.c        **** }/* uart_init */
 226               		.loc 1 481 0
 227 00e0 0895      		ret
 228               		.cfi_endproc
 229               	.LFE3:
 231               	.global	uart_getc
 233               	uart_getc:
 234               	.LFB4:
 482:uart.c        **** 
 483:uart.c        **** 
 484:uart.c        **** /*************************************************************************
 485:uart.c        **** Function: uart_getc()
 486:uart.c        **** Purpose:  return byte from ringbuffer  
 487:uart.c        **** Returns:  lower byte:  received byte from ringbuffer
 488:uart.c        ****           higher byte: last receive error
 489:uart.c        **** **************************************************************************/
 490:uart.c        **** unsigned int uart_getc(void)
 491:uart.c        **** {    
 235               		.loc 1 491 0
 236               		.cfi_startproc
 237               	/* prologue: function */
 238               	/* frame size = 0 */
 239               	/* stack size = 0 */
 240               	.L__stack_usage = 0
 492:uart.c        ****     unsigned char tmptail;
 493:uart.c        ****     unsigned char data;
 494:uart.c        ****     unsigned char lastRxError;
 495:uart.c        **** 
 496:uart.c        **** 
 497:uart.c        ****     if ( UART_RxHead == UART_RxTail ) {
 241               		.loc 1 497 0
 242 00e2 9091 0000 		lds r25,UART_RxHead
 243 00e6 8091 0000 		lds r24,UART_RxTail
 244 00ea 9817      		cp r25,r24
 245 00ec 01F0      		breq .L11
 498:uart.c        ****         return UART_NO_DATA;   /* no data available */
 499:uart.c        ****     }
 500:uart.c        ****     
 501:uart.c        ****     /* calculate buffer index */
 502:uart.c        ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 246               		.loc 1 502 0
 247 00ee 8091 0000 		lds r24,UART_RxTail
 248 00f2 8F5F      		subi r24,lo8(-(1))
 249 00f4 8F71      		andi r24,lo8(31)
 250               	.LVL14:
 503:uart.c        ****     
 504:uart.c        ****     /* get data from receive buffer */
 505:uart.c        ****     data = UART_RxBuf[tmptail];
 251               		.loc 1 505 0
 252 00f6 E82F      		mov r30,r24
 253 00f8 F0E0      		ldi r31,lo8(0)
 254 00fa E050      		subi r30,lo8(-(UART_RxBuf))
 255 00fc F040      		sbci r31,hi8(-(UART_RxBuf))
 256 00fe 2081      		ld r18,Z
 257               	.LVL15:
 506:uart.c        ****     lastRxError = UART_LastRxError;
 258               		.loc 1 506 0
 259 0100 3091 0000 		lds r19,UART_LastRxError
 260               	.LVL16:
 507:uart.c        ****     
 508:uart.c        ****     /* store buffer index */
 509:uart.c        ****     UART_RxTail = tmptail; 
 261               		.loc 1 509 0
 262 0104 8093 0000 		sts UART_RxTail,r24
 510:uart.c        ****     
 511:uart.c        ****     UART_LastRxError = 0;
 263               		.loc 1 511 0
 264 0108 1092 0000 		sts UART_LastRxError,__zero_reg__
 512:uart.c        ****     return (lastRxError << 8) + data;
 265               		.loc 1 512 0
 266 010c 932F      		mov r25,r19
 267 010e 80E0      		ldi r24,lo8(0)
 268               	.LVL17:
 269 0110 820F      		add r24,r18
 270 0112 911D      		adc r25,__zero_reg__
 271 0114 0895      		ret
 272               	.LVL18:
 273               	.L11:
 498:uart.c        ****         return UART_NO_DATA;   /* no data available */
 274               		.loc 1 498 0
 275 0116 80E0      		ldi r24,lo8(256)
 276 0118 91E0      		ldi r25,hi8(256)
 513:uart.c        **** 
 514:uart.c        **** }/* uart_getc */
 277               		.loc 1 514 0
 278 011a 0895      		ret
 279               		.cfi_endproc
 280               	.LFE4:
 282               	.global	uart_putc
 284               	uart_putc:
 285               	.LFB5:
 515:uart.c        **** 
 516:uart.c        **** 
 517:uart.c        **** /*************************************************************************
 518:uart.c        **** Function: uart_putc()
 519:uart.c        **** Purpose:  write byte to ringbuffer for transmitting via UART
 520:uart.c        **** Input:    byte to be transmitted
 521:uart.c        **** Returns:  none          
 522:uart.c        **** **************************************************************************/
 523:uart.c        **** void uart_putc(unsigned char data)
 524:uart.c        **** {
 286               		.loc 1 524 0
 287               		.cfi_startproc
 288               	.LVL19:
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
 525:uart.c        ****     unsigned char tmphead;
 526:uart.c        **** 
 527:uart.c        ****     
 528:uart.c        ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 293               		.loc 1 528 0
 294 011c 9091 0000 		lds r25,UART_TxHead
 295 0120 9F5F      		subi r25,lo8(-(1))
 296 0122 9F71      		andi r25,lo8(31)
 297               	.LVL20:
 298               	.L13:
 529:uart.c        ****     
 530:uart.c        ****     while ( tmphead == UART_TxTail ){
 299               		.loc 1 530 0 discriminator 1
 300 0124 2091 0000 		lds r18,UART_TxTail
 301 0128 9217      		cp r25,r18
 302 012a 01F0      		breq .L13
 531:uart.c        ****         ;/* wait for free space in buffer */
 532:uart.c        ****     }
 533:uart.c        ****     
 534:uart.c        ****     UART_TxBuf[tmphead] = data;
 303               		.loc 1 534 0
 304 012c E92F      		mov r30,r25
 305 012e F0E0      		ldi r31,lo8(0)
 306 0130 E050      		subi r30,lo8(-(UART_TxBuf))
 307 0132 F040      		sbci r31,hi8(-(UART_TxBuf))
 308 0134 8083      		st Z,r24
 535:uart.c        ****     UART_TxHead = tmphead;
 309               		.loc 1 535 0
 310 0136 9093 0000 		sts UART_TxHead,r25
 536:uart.c        **** 
 537:uart.c        ****     /* enable UDRE interrupt */
 538:uart.c        ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 311               		.loc 1 538 0
 312 013a 8091 C100 		lds r24,193
 313               	.LVL21:
 314 013e 8062      		ori r24,lo8(32)
 315 0140 8093 C100 		sts 193,r24
 316               	/* epilogue start */
 539:uart.c        **** 
 540:uart.c        **** }/* uart_putc */
 317               		.loc 1 540 0
 318 0144 0895      		ret
 319               		.cfi_endproc
 320               	.LFE5:
 322               	.global	uart_puts
 324               	uart_puts:
 325               	.LFB6:
 541:uart.c        **** 
 542:uart.c        **** 
 543:uart.c        **** /*************************************************************************
 544:uart.c        **** Function: uart_puts()
 545:uart.c        **** Purpose:  transmit string to UART
 546:uart.c        **** Input:    string to be transmitted
 547:uart.c        **** Returns:  none          
 548:uart.c        **** **************************************************************************/
 549:uart.c        **** void uart_puts(const char *s )
 550:uart.c        **** {
 326               		.loc 1 550 0
 327               		.cfi_startproc
 328               	.LVL22:
 329 0146 CF93      		push r28
 330               	.LCFI13:
 331               		.cfi_def_cfa_offset 3
 332               		.cfi_offset 28, -2
 333 0148 DF93      		push r29
 334               	.LCFI14:
 335               		.cfi_def_cfa_offset 4
 336               		.cfi_offset 29, -3
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 2 */
 340               	.L__stack_usage = 2
 341               		.loc 1 550 0
 342 014a EC01      		movw r28,r24
 551:uart.c        ****     while (*s) 
 343               		.loc 1 551 0
 344 014c 00C0      		rjmp .L16
 345               	.LVL23:
 346               	.L17:
 552:uart.c        ****       uart_putc(*s++);
 347               		.loc 1 552 0
 348 014e 0E94 0000 		call uart_putc
 349               	.L16:
 551:uart.c        ****     while (*s) 
 350               		.loc 1 551 0 discriminator 1
 351 0152 8991      		ld r24,Y+
 352 0154 8823      		tst r24
 353 0156 01F4      		brne .L17
 354               	/* epilogue start */
 553:uart.c        **** 
 554:uart.c        **** }/* uart_puts */
 355               		.loc 1 554 0
 356 0158 DF91      		pop r29
 357 015a CF91      		pop r28
 358 015c 0895      		ret
 359               		.cfi_endproc
 360               	.LFE6:
 362               	.global	uart_puts_p
 364               	uart_puts_p:
 365               	.LFB7:
 555:uart.c        **** 
 556:uart.c        **** 
 557:uart.c        **** /*************************************************************************
 558:uart.c        **** Function: uart_puts_p()
 559:uart.c        **** Purpose:  transmit string from program memory to UART
 560:uart.c        **** Input:    program memory string to be transmitted
 561:uart.c        **** Returns:  none
 562:uart.c        **** **************************************************************************/
 563:uart.c        **** void uart_puts_p(const char *progmem_s )
 564:uart.c        **** {
 366               		.loc 1 564 0
 367               		.cfi_startproc
 368               	.LVL24:
 369 015e CF93      		push r28
 370               	.LCFI15:
 371               		.cfi_def_cfa_offset 3
 372               		.cfi_offset 28, -2
 373 0160 DF93      		push r29
 374               	.LCFI16:
 375               		.cfi_def_cfa_offset 4
 376               		.cfi_offset 29, -3
 377               	/* prologue: function */
 378               	/* frame size = 0 */
 379               	/* stack size = 2 */
 380               	.L__stack_usage = 2
 381 0162 EC01      		movw r28,r24
 565:uart.c        ****     register char c;
 566:uart.c        ****     
 567:uart.c        ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 382               		.loc 1 567 0
 383 0164 00C0      		rjmp .L19
 384               	.LVL25:
 385               	.L20:
 568:uart.c        ****       uart_putc(c);
 386               		.loc 1 568 0
 387 0166 0E94 0000 		call uart_putc
 388               	.LVL26:
 389               	.L19:
 390               	.LBB2:
 567:uart.c        ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 391               		.loc 1 567 0 discriminator 1
 392 016a FE01      		movw r30,r28
 393               	.LVL27:
 394 016c 2196      		adiw r28,1
 395               	.LVL28:
 396               	/* #APP */
 397               	 ;  567 "uart.c" 1
 398 016e 8491      		lpm r24, Z
 399               		
 400               	 ;  0 "" 2
 401               	.LVL29:
 402               	/* #NOAPP */
 403               	.LBE2:
 404 0170 8823      		tst r24
 405 0172 01F4      		brne .L20
 406               	/* epilogue start */
 569:uart.c        **** 
 570:uart.c        **** }/* uart_puts_p */
 407               		.loc 1 570 0
 408 0174 DF91      		pop r29
 409 0176 CF91      		pop r28
 410               	.LVL30:
 411 0178 0895      		ret
 412               		.cfi_endproc
 413               	.LFE7:
 415               		.lcomm UART_LastRxError,1
 416               		.lcomm UART_RxTail,1
 417               		.lcomm UART_RxHead,1
 418               		.lcomm UART_TxTail,1
 419               		.lcomm UART_TxHead,1
 420               		.lcomm UART_RxBuf,32
 421               		.lcomm UART_TxBuf,32
 422               	.Letext0:
 423               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
              uart.s:2      *ABS*:0000003f __SREG__
              uart.s:3      *ABS*:0000003e __SP_H__
              uart.s:4      *ABS*:0000003d __SP_L__
              uart.s:5      *ABS*:00000034 __CCP__
              uart.s:6      *ABS*:00000000 __tmp_reg__
              uart.s:7      *ABS*:00000001 __zero_reg__
              uart.s:15     .text:00000000 __vector_18
              uart.s:416    .bss:00000002 UART_RxHead
              uart.s:415    .bss:00000001 UART_RxTail
              uart.s:419    .bss:00000005 UART_RxBuf
                             .bss:00000000 UART_LastRxError
              uart.s:111    .text:0000005c __vector_19
              uart.s:418    .bss:00000004 UART_TxHead
              uart.s:417    .bss:00000003 UART_TxTail
              uart.s:420    .bss:00000025 UART_TxBuf
              uart.s:189    .text:000000b0 uart_init
              uart.s:233    .text:000000e2 uart_getc
              uart.s:284    .text:0000011c uart_putc
              uart.s:324    .text:00000146 uart_puts
              uart.s:364    .text:0000015e uart_puts_p

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
