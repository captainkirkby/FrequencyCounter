   1               		.file	"test_lcd.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	wait_until_key_pressed
  15               	wait_until_key_pressed:
  16               	.LFB7:
  17               		.file 1 "test_lcd.c"
   1:test_lcd.c    **** /*************************************************************************
   2:test_lcd.c    **** Title:    Testing output to a HD44780 based LCD display.
   3:test_lcd.c    **** Author:   Peter Fleury  <pfleury@gmx.ch>  http://tinyurl.com/peterfleury
   4:test_lcd.c    **** File:     $Id: test_lcd.c,v 1.8 2015/01/31 18:04:08 peter Exp $
   5:test_lcd.c    **** Software: AVR-GCC 4.x
   6:test_lcd.c    **** Hardware: HD44780 compatible LCD text display
   7:test_lcd.c    ****           AVR with external SRAM interface if memory-mapped LCD interface is used
   8:test_lcd.c    ****           any AVR with 7 free I/O pins if 4-bit IO port mode is used
   9:test_lcd.c    **** **************************************************************************/
  10:test_lcd.c    **** #include <stdlib.h>
  11:test_lcd.c    **** #include <avr/io.h>
  12:test_lcd.c    **** #include <avr/pgmspace.h>
  13:test_lcd.c    **** #include <util/delay.h>
  14:test_lcd.c    **** #include "lcd.h"
  15:test_lcd.c    **** 
  16:test_lcd.c    **** 
  17:test_lcd.c    **** /*
  18:test_lcd.c    **** ** constant definitions
  19:test_lcd.c    **** */
  20:test_lcd.c    **** static const PROGMEM unsigned char copyRightChar[] =
  21:test_lcd.c    **** {
  22:test_lcd.c    **** 	0x07, 0x08, 0x13, 0x14, 0x14, 0x13, 0x08, 0x07,
  23:test_lcd.c    **** 	0x00, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x00
  24:test_lcd.c    **** };
  25:test_lcd.c    **** 
  26:test_lcd.c    **** 
  27:test_lcd.c    **** /*
  28:test_lcd.c    **** ** function prototypes
  29:test_lcd.c    **** */ 
  30:test_lcd.c    **** void wait_until_key_pressed(void);
  31:test_lcd.c    **** 
  32:test_lcd.c    **** 
  33:test_lcd.c    **** void wait_until_key_pressed(void)
  34:test_lcd.c    **** {
  18               		.loc 1 34 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  24               	.L2:
  35:test_lcd.c    ****     unsigned char temp1, temp2;
  36:test_lcd.c    ****     
  37:test_lcd.c    ****     do {
  38:test_lcd.c    ****         temp1 = PINB;                  // read input
  25               		.loc 1 38 0 discriminator 1
  26 0000 93B1      		in r25,35-32
  27               	.LVL0:
  28               	.LBB4:
  29               	.LBB5:
  30               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  31               		.loc 2 164 0 discriminator 1
  32 0002 EFE1      		 ldi r30,lo8(19999)
  33 0004 FEE4      	    ldi r31,hi8(19999)
  34 0006 3197      	    1:sbiw r30,1
  35 0008 01F4      	    brne 1b
  36 000a 00C0      		rjmp .
  37 000c 0000      		nop
  38               	.LBE5:
  39               	.LBE4:
  39:test_lcd.c    ****         _delay_ms(5);                  // delay for key debounce
  40:test_lcd.c    ****         temp2 = PINB;                  // read input
  40               		.loc 1 40 0 discriminator 1
  41 000e 83B1      		in r24,35-32
  42               	.LVL1:
  41:test_lcd.c    ****         temp1 = (temp1 & temp2);       // debounce input
  43               		.loc 1 41 0 discriminator 1
  44 0010 8923      		and r24,r25
  45               	.LVL2:
  42:test_lcd.c    ****     } while ( temp1 & _BV(PINB2) );
  46               		.loc 1 42 0 discriminator 1
  47 0012 82FD      		sbrc r24,2
  48 0014 00C0      		rjmp .L2
  49               	.L4:
  43:test_lcd.c    ****     
  44:test_lcd.c    ****     loop_until_bit_is_set(PINB,PINB2);            /* wait until key is released */
  50               		.loc 1 44 0 discriminator 1
  51 0016 1A9B      		sbis 35-32,2
  52 0018 00C0      		rjmp .L4
  53               	/* epilogue start */
  45:test_lcd.c    **** }
  54               		.loc 1 45 0
  55 001a 0895      		ret
  56               		.cfi_endproc
  57               	.LFE7:
  59               		.data
  60               	.LC0:
  61 0000 4C43 4420 		.string	"LCD Test Line 1\n"
  61      5465 7374 
  61      204C 696E 
  61      6520 310A 
  61      00
  62               	.LC1:
  63 0011 4C69 6E65 		.string	"Line 2"
  63      2032 00
  64               	.LC2:
  65 0018 4375 724F 		.string	"CurOn"
  65      6E00 
  66               	.LC3:
  67 001e 436F 7079 		.string	"Copyright: "
  67      7269 6768 
  67      743A 2000 
  68               		.section	.text.startup,"ax",@progbits
  69               	.global	main
  71               	main:
  72               	.LFB8:
  46:test_lcd.c    **** 
  47:test_lcd.c    **** 
  48:test_lcd.c    **** int main(void)
  49:test_lcd.c    **** {
  73               		.loc 1 49 0
  74               		.cfi_startproc
  75 0000 CF93      		push r28
  76               	.LCFI0:
  77               		.cfi_def_cfa_offset 3
  78               		.cfi_offset 28, -2
  79 0002 DF93      		push r29
  80               	.LCFI1:
  81               		.cfi_def_cfa_offset 4
  82               		.cfi_offset 29, -3
  83 0004 CDB7      		in r28,__SP_L__
  84 0006 DEB7      		in r29,__SP_H__
  85 0008 2797      		sbiw r28,7
  86               	.LCFI2:
  87               		.cfi_def_cfa 28, 11
  88 000a 0FB6      		in __tmp_reg__,__SREG__
  89 000c F894      		cli
  90 000e DEBF      		out __SP_H__,r29
  91 0010 0FBE      		out __SREG__,__tmp_reg__
  92 0012 CDBF      		out __SP_L__,r28
  93               	/* prologue: function */
  94               	/* frame size = 7 */
  95               	/* stack size = 9 */
  96               	.L__stack_usage = 9
  97               	.LVL3:
  50:test_lcd.c    ****     char buffer[7];
  51:test_lcd.c    ****     int  num=134;
  52:test_lcd.c    ****     unsigned char i;
  53:test_lcd.c    ****     
  54:test_lcd.c    ****     
  55:test_lcd.c    ****     DDRB &=~ (1 << PB2);        /* Pin PB2 input              */
  98               		.loc 1 55 0
  99 0014 2298      		cbi 36-32,2
  56:test_lcd.c    ****     PORTB |= (1 << PB2);        /* Pin PB2 pull-up enabled    */
 100               		.loc 1 56 0
 101 0016 2A9A      		sbi 37-32,2
  57:test_lcd.c    **** 
  58:test_lcd.c    **** 
  59:test_lcd.c    ****     /* initialize display, cursor off */
  60:test_lcd.c    ****     lcd_init(LCD_DISP_ON);
 102               		.loc 1 60 0
 103 0018 8CE0      		ldi r24,lo8(12)
 104 001a 0E94 0000 		call lcd_init
 105               	.L9:
  61:test_lcd.c    **** 
  62:test_lcd.c    ****     for (;;) {                           /* loop forever */
  63:test_lcd.c    ****         /* 
  64:test_lcd.c    ****          * Test 1:  write text to display
  65:test_lcd.c    ****          */
  66:test_lcd.c    **** 
  67:test_lcd.c    ****         /* clear display and home cursor */
  68:test_lcd.c    ****         lcd_clrscr();
 106               		.loc 1 68 0
 107 001e 0E94 0000 		call lcd_clrscr
  69:test_lcd.c    ****         
  70:test_lcd.c    ****         /* put string to display (line 1) with linefeed */
  71:test_lcd.c    ****         lcd_puts("LCD Test Line 1\n");
 108               		.loc 1 71 0
 109 0022 80E0      		ldi r24,lo8(.LC0)
 110 0024 90E0      		ldi r25,hi8(.LC0)
 111 0026 0E94 0000 		call lcd_puts
  72:test_lcd.c    **** 
  73:test_lcd.c    ****         /* cursor is now on second line, write second line */
  74:test_lcd.c    ****         lcd_puts("Line 2");
 112               		.loc 1 74 0
 113 002a 80E0      		ldi r24,lo8(.LC1)
 114 002c 90E0      		ldi r25,hi8(.LC1)
 115 002e 0E94 0000 		call lcd_puts
  75:test_lcd.c    ****         
  76:test_lcd.c    ****         /* move cursor to position 8 on line 2 */
  77:test_lcd.c    ****         lcd_gotoxy(7,1);  
 116               		.loc 1 77 0
 117 0032 87E0      		ldi r24,lo8(7)
 118 0034 61E0      		ldi r22,lo8(1)
 119 0036 0E94 0000 		call lcd_gotoxy
  78:test_lcd.c    ****         
  79:test_lcd.c    ****         /* write single char to display */
  80:test_lcd.c    ****         lcd_putc(':');
 120               		.loc 1 80 0
 121 003a 8AE3      		ldi r24,lo8(58)
 122 003c 0E94 0000 		call lcd_putc
  81:test_lcd.c    ****         
  82:test_lcd.c    ****         /* wait until push button PB2 is pressed */
  83:test_lcd.c    ****         wait_until_key_pressed();
 123               		.loc 1 83 0
 124 0040 0E94 0000 		call wait_until_key_pressed
  84:test_lcd.c    ****         
  85:test_lcd.c    ****         
  86:test_lcd.c    ****         /*
  87:test_lcd.c    ****          * Test 2: use lcd_command() to turn on cursor
  88:test_lcd.c    ****          */
  89:test_lcd.c    ****         
  90:test_lcd.c    ****         /* turn on cursor */
  91:test_lcd.c    ****         lcd_command(LCD_DISP_ON_CURSOR);
 125               		.loc 1 91 0
 126 0044 8EE0      		ldi r24,lo8(14)
 127 0046 0E94 0000 		call lcd_command
  92:test_lcd.c    **** 
  93:test_lcd.c    ****         /* put string */
  94:test_lcd.c    ****         lcd_puts( "CurOn");
 128               		.loc 1 94 0
 129 004a 80E0      		ldi r24,lo8(.LC2)
 130 004c 90E0      		ldi r25,hi8(.LC2)
 131 004e 0E94 0000 		call lcd_puts
  95:test_lcd.c    ****         
  96:test_lcd.c    ****         /* wait until push button PB2 is pressed */
  97:test_lcd.c    ****         wait_until_key_pressed();
 132               		.loc 1 97 0
 133 0052 0E94 0000 		call wait_until_key_pressed
  98:test_lcd.c    **** 
  99:test_lcd.c    **** 
 100:test_lcd.c    ****         /*
 101:test_lcd.c    ****          * Test 3: display shift
 102:test_lcd.c    ****          */
 103:test_lcd.c    ****         
 104:test_lcd.c    ****         lcd_clrscr();     /* clear display home cursor */
 134               		.loc 1 104 0
 135 0056 0E94 0000 		call lcd_clrscr
 105:test_lcd.c    **** 
 106:test_lcd.c    ****         /* put string from program memory to display */
 107:test_lcd.c    ****         lcd_puts_P( "Line 1 longer than 14 characters\n" );
 136               		.loc 1 107 0
 137 005a 80E0      		ldi r24,lo8(__c.1698)
 138 005c 90E0      		ldi r25,hi8(__c.1698)
 139 005e 0E94 0000 		call lcd_puts_p
 108:test_lcd.c    ****         lcd_puts_P( "Line 2 longer than 14 characters" );
 140               		.loc 1 108 0
 141 0062 80E0      		ldi r24,lo8(__c.1700)
 142 0064 90E0      		ldi r25,hi8(__c.1700)
 143 0066 0E94 0000 		call lcd_puts_p
 109:test_lcd.c    ****         
 110:test_lcd.c    ****         /* move BOTH lines one position to the left */
 111:test_lcd.c    ****         lcd_command(LCD_MOVE_DISP_LEFT);
 144               		.loc 1 111 0
 145 006a 88E1      		ldi r24,lo8(24)
 146 006c 0E94 0000 		call lcd_command
 112:test_lcd.c    ****         
 113:test_lcd.c    ****         /* wait until push button PB2 is pressed */
 114:test_lcd.c    ****         wait_until_key_pressed();
 147               		.loc 1 114 0
 148 0070 0E94 0000 		call wait_until_key_pressed
 115:test_lcd.c    **** 
 116:test_lcd.c    ****         /* turn off cursor */
 117:test_lcd.c    ****         lcd_command(LCD_DISP_ON);
 149               		.loc 1 117 0
 150 0074 8CE0      		ldi r24,lo8(12)
 151 0076 0E94 0000 		call lcd_command
 118:test_lcd.c    ****         
 119:test_lcd.c    ****         
 120:test_lcd.c    ****         /*
 121:test_lcd.c    ****          *   Test: Display integer values
 122:test_lcd.c    ****          */
 123:test_lcd.c    ****         
 124:test_lcd.c    ****         lcd_clrscr();   /* clear display home cursor */
 152               		.loc 1 124 0
 153 007a 0E94 0000 		call lcd_clrscr
 125:test_lcd.c    ****         
 126:test_lcd.c    ****         /* convert interger into string */
 127:test_lcd.c    ****         itoa( num , buffer, 10);
 154               		.loc 1 127 0
 155 007e 86E8      		ldi r24,lo8(134)
 156 0080 90E0      		ldi r25,hi8(134)
 157 0082 BE01      		movw r22,r28
 158 0084 6F5F      		subi r22,lo8(-(1))
 159 0086 7F4F      		sbci r23,hi8(-(1))
 160 0088 4AE0      		ldi r20,lo8(10)
 161 008a 50E0      		ldi r21,hi8(10)
 162 008c 0E94 0000 		call itoa
 128:test_lcd.c    ****         
 129:test_lcd.c    ****         /* put converted string to display */
 130:test_lcd.c    ****         lcd_puts(buffer);
 163               		.loc 1 130 0
 164 0090 CE01      		movw r24,r28
 165 0092 0196      		adiw r24,1
 166 0094 0E94 0000 		call lcd_puts
 131:test_lcd.c    ****         
 132:test_lcd.c    ****         /* wait until push button PB2 is pressed */
 133:test_lcd.c    ****         wait_until_key_pressed();
 167               		.loc 1 133 0
 168 0098 0E94 0000 		call wait_until_key_pressed
 134:test_lcd.c    ****         
 135:test_lcd.c    ****         
 136:test_lcd.c    ****         /*
 137:test_lcd.c    ****          *  Test: Display userdefined characters
 138:test_lcd.c    ****          */
 139:test_lcd.c    **** 
 140:test_lcd.c    ****        lcd_clrscr();   /* clear display home cursor */
 169               		.loc 1 140 0
 170 009c 0E94 0000 		call lcd_clrscr
 141:test_lcd.c    ****        
 142:test_lcd.c    ****        lcd_puts("Copyright: ");
 171               		.loc 1 142 0
 172 00a0 80E0      		ldi r24,lo8(.LC3)
 173 00a2 90E0      		ldi r25,hi8(.LC3)
 174 00a4 0E94 0000 		call lcd_puts
 143:test_lcd.c    ****        
 144:test_lcd.c    ****        /*
 145:test_lcd.c    ****         * load two userdefined characters from program memory
 146:test_lcd.c    ****         * into LCD controller CG RAM location 0 and 1
 147:test_lcd.c    ****         */
 148:test_lcd.c    ****        lcd_command(_BV(LCD_CGRAM));  /* set CG RAM start address 0 */
 175               		.loc 1 148 0
 176 00a8 80E4      		ldi r24,lo8(64)
 177 00aa 0E94 0000 		call lcd_command
 178               	.LVL4:
 179 00ae 00E0      		ldi r16,lo8(0)
 180 00b0 10E0      		ldi r17,hi8(0)
 181               	.LVL5:
 182               	.L8:
 183               	.LBB6:
 149:test_lcd.c    ****        for(i=0; i<16; i++)
 150:test_lcd.c    ****        {
 151:test_lcd.c    ****            lcd_data(pgm_read_byte_near(&copyRightChar[i]));
 184               		.loc 1 151 0 discriminator 2
 185 00b2 F801      		movw r30,r16
 186 00b4 E050      		subi r30,lo8(-(copyRightChar))
 187 00b6 F040      		sbci r31,hi8(-(copyRightChar))
 188               	/* #APP */
 189               	 ;  151 "test_lcd.c" 1
 190 00b8 8491      		lpm r24, Z
 191               		
 192               	 ;  0 "" 2
 193               	.LVL6:
 194               	/* #NOAPP */
 195               	.LBE6:
 196 00ba 0E94 0000 		call lcd_data
 197               	.LVL7:
 198 00be 0F5F      		subi r16,lo8(-(1))
 199 00c0 1F4F      		sbci r17,hi8(-(1))
 200               	.LVL8:
 149:test_lcd.c    ****        for(i=0; i<16; i++)
 201               		.loc 1 149 0 discriminator 2
 202 00c2 0031      		cpi r16,16
 203 00c4 1105      		cpc r17,__zero_reg__
 204 00c6 01F4      		brne .L8
 152:test_lcd.c    ****        }
 153:test_lcd.c    ****        
 154:test_lcd.c    ****        /* move cursor to position 0 on line 2 */
 155:test_lcd.c    ****        /* Note: this switched back to DD RAM adresses */
 156:test_lcd.c    ****        lcd_gotoxy(0,1);
 205               		.loc 1 156 0
 206 00c8 80E0      		ldi r24,lo8(0)
 207 00ca 61E0      		ldi r22,lo8(1)
 208 00cc 0E94 0000 		call lcd_gotoxy
 157:test_lcd.c    ****        
 158:test_lcd.c    ****        /* display user defined (c), built using two user defined chars */
 159:test_lcd.c    ****        lcd_putc(0);
 209               		.loc 1 159 0
 210 00d0 80E0      		ldi r24,lo8(0)
 211 00d2 0E94 0000 		call lcd_putc
 160:test_lcd.c    ****        lcd_putc(1);
 212               		.loc 1 160 0
 213 00d6 81E0      		ldi r24,lo8(1)
 214 00d8 0E94 0000 		call lcd_putc
 161:test_lcd.c    ****        
 162:test_lcd.c    **** 
 163:test_lcd.c    ****        /* wait until push button PD2 (INT0) is pressed */
 164:test_lcd.c    ****        wait_until_key_pressed();
 215               		.loc 1 164 0
 216 00dc 0E94 0000 		call wait_until_key_pressed
 165:test_lcd.c    ****               
 166:test_lcd.c    ****     }
 217               		.loc 1 166 0
 218 00e0 00C0      		rjmp .L9
 219               		.cfi_endproc
 220               	.LFE8:
 222               		.section	.progmem.data,"a",@progbits
 225               	__c.1698:
 226 0000 4C69 6E65 		.string	"Line 1 longer than 14 characters\n"
 226      2031 206C 
 226      6F6E 6765 
 226      7220 7468 
 226      616E 2031 
 229               	__c.1700:
 230 0022 4C69 6E65 		.string	"Line 2 longer than 14 characters"
 230      2032 206C 
 230      6F6E 6765 
 230      7220 7468 
 230      616E 2031 
 233               	copyRightChar:
 234 0043 07        		.byte	7
 235 0044 08        		.byte	8
 236 0045 13        		.byte	19
 237 0046 14        		.byte	20
 238 0047 14        		.byte	20
 239 0048 13        		.byte	19
 240 0049 08        		.byte	8
 241 004a 07        		.byte	7
 242 004b 00        		.byte	0
 243 004c 10        		.byte	16
 244 004d 08        		.byte	8
 245 004e 08        		.byte	8
 246 004f 08        		.byte	8
 247 0050 08        		.byte	8
 248 0051 10        		.byte	16
 249 0052 00        		.byte	0
 250               		.text
 251               	.Letext0:
 252               		.file 3 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 test_lcd.c
          test_lcd.s:2      *ABS*:0000003f __SREG__
          test_lcd.s:3      *ABS*:0000003e __SP_H__
          test_lcd.s:4      *ABS*:0000003d __SP_L__
          test_lcd.s:5      *ABS*:00000034 __CCP__
          test_lcd.s:6      *ABS*:00000000 __tmp_reg__
          test_lcd.s:7      *ABS*:00000001 __zero_reg__
          test_lcd.s:15     .text:00000000 wait_until_key_pressed
          test_lcd.s:71     .text.startup:00000000 main
          test_lcd.s:225    .progmem.data:00000000 __c.1698
          test_lcd.s:229    .progmem.data:00000022 __c.1700
          test_lcd.s:233    .progmem.data:00000043 copyRightChar

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
lcd_init
lcd_clrscr
lcd_puts
lcd_gotoxy
lcd_putc
lcd_command
lcd_puts_p
itoa
lcd_data
